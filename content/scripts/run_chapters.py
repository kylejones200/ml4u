#!/usr/bin/env python3
import os
import sys
import subprocess
import time
import json
from pathlib import Path
from typing import List, Dict, Optional

CONTENT = Path(__file__).resolve().parents[1]
ROOT = CONTENT.parent

TIMEOUT_SEC = int(os.environ.get("ML4U_CHAPTER_TIMEOUT", "300"))  # default 5 min per chapter

IMAGE_EXTS = {".png", ".jpg", ".jpeg", ".svg"}


def find_chapter_dirs() -> List[Path]:
    return sorted([p for p in (CONTENT).iterdir() if p.is_dir() and p.name.startswith("c") and p.name[1:].isdigit()])


def find_main_script(chapter_dir: Path) -> Optional[Path]:
    # Prefer a .py file whose name matches the directory name, else the only .py, else first .py
    py_files = sorted(chapter_dir.glob("*.py"))
    if not py_files:
        return None
    preferred = chapter_dir / f"{chapter_dir.name[1:]}.py"  # unlikely, but try numeric
    if preferred.exists():
        return preferred
    # Try a file that contains the directory name (e.g., c4 -> load_forecasting.py)
    for f in py_files:
        if chapter_dir.name.lower().strip() in f.name.lower():
            return f
    # If only one, return it; else pick the first
    if len(py_files) == 1:
        return py_files[0]
    # Heuristic: pick index.md front-matter pyfile if present
    idx = chapter_dir / "index.md"
    if idx.exists():
        try:
            import re
            text = idx.read_text(encoding="utf-8")
            m = re.search(r"pyfile:\s*\"([^\"]+)\"", text)
            if m:
                candidate = chapter_dir / m.group(1)
                if candidate.exists():
                    return candidate
        except Exception:
            pass
    return py_files[0]


def list_images(dir_path: Path) -> set:
    return {p.name for p in dir_path.iterdir() if p.is_file() and p.suffix.lower() in IMAGE_EXTS}


def run_chapter(chapter_dir: Path, script_path: Path) -> Dict:
    env = os.environ.copy()
    env.setdefault("MPLBACKEND", "Agg")  # non-interactive backend to avoid blocking
    env.setdefault("PYTHONUNBUFFERED", "1")

    before_imgs = list_images(chapter_dir)
    log_path = chapter_dir / f"{chapter_dir.name}_run.log"
    cmd = [sys.executable, str(script_path.name)]

    start = time.time()
    try:
        proc = subprocess.run(
            cmd,
            cwd=str(chapter_dir),
            env=env,
            capture_output=True,
            text=True,
            timeout=TIMEOUT_SEC,
            check=False,
        )
        duration = time.time() - start
        log_path.write_text(
            f"$ {' '.join(cmd)}\n\n" +
            f"Return code: {proc.returncode}\nDuration: {duration:.1f}s\n\n" +
            "--- STDOUT ---\n" + proc.stdout + "\n\n--- STDERR ---\n" + proc.stderr,
            encoding="utf-8",
        )
        after_imgs = list_images(chapter_dir)
        new_imgs = sorted(list(after_imgs - before_imgs))
        return {
            "chapter": chapter_dir.name,
            "script": script_path.name,
            "status": "pass" if proc.returncode == 0 else "fail",
            "returncode": proc.returncode,
            "duration_sec": round(duration, 1),
            "new_images": new_imgs,
            "log": str(log_path.relative_to(ROOT)),
        }
    except subprocess.TimeoutExpired as e:
        duration = time.time() - start
        log_path.write_text(
            f"$ {' '.join(cmd)}\n\nTimed out after {TIMEOUT_SEC}s.\n\n--- PARTIAL STDOUT ---\n{e.stdout or ''}\n\n--- PARTIAL STDERR ---\n{e.stderr or ''}",
            encoding="utf-8",
        )
        return {
            "chapter": chapter_dir.name,
            "script": script_path.name,
            "status": "timeout",
            "returncode": None,
            "duration_sec": round(duration, 1),
            "new_images": [],
            "log": str(log_path.relative_to(ROOT)),
        }


def main():
    chapters = find_chapter_dirs()
    results = []
    for ch in chapters:
        script = find_main_script(ch)
        if not script:
            results.append({
                "chapter": ch.name,
                "script": None,
                "status": "no_script",
                "returncode": None,
                "duration_sec": 0,
                "new_images": [],
                "log": None,
            })
            continue
        print(f"Running {ch.name}/{script.name}...")
        res = run_chapter(ch, script)
        results.append(res)

    report_path = CONTENT / "chapter_test_report.json"
    report_path.write_text(json.dumps(results, indent=2), encoding="utf-8")
    # Also write a simple markdown summary
    md_lines = ["# Chapter Test Report", "", "- Generated by content/scripts/run_chapters.py", ""]
    for r in results:
        md_lines.append(f"- **{r['chapter']}** — {r['status'].upper()} — script: `{r['script']}` — images: {', '.join(r['new_images']) if r['new_images'] else 'none'} — log: `{r['log']}`")
    (CONTENT / "chapter_test_report.md").write_text("\n".join(md_lines) + "\n", encoding="utf-8")
    print(f"Wrote report to {report_path}")


if __name__ == "__main__":
    main()
